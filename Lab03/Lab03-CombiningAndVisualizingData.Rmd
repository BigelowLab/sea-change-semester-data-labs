---
title: "Lab 3: Combining and Visualizing Data Sets"
output: html_notebook
---

In this lab we are going to 

1. Combine the discrete and CTD data into one data set
2. Visualize the data

# Formatting Data

Last day, we created a CSV file with all the CTD data from `DaRTS_cruise_data_2012-2020 - 20201103.xlsx`. Before combining our CTD data with the discrete data, we need to create a CSV file with the discrete data.

1. Open `DaRTS_cruise_data_2012-2020 – 20201103.xlsx` (the full data set file) in Excel
2. Go to the "Depth Discrete Data" sheet
1. Go to "File" -> "Save As" and select to save the file as a "CSV (Comma delimited)" file named DaRTS_discrete_data (selecting "yes"" to the windows that pop up)
2. Exit the Excel file (selecting "no" you don't want to save changes if asked) 
3. Open the csv file you just created in Excel (the easiest way to do this is open Excel, then do "File" -> "Open" -> "Browse", then navigate to the file and select "Open")

Once you've opened the CSV file

1. Combine the information in the first three rows into the one row by replacing the spaces, parentheses and forward slashes with underscores
2. Delete the extra rows at the top of the sheet
2. Change the dates `10/1/2013 and 10/4/2013` to `10/1/2013`
3. Press CTRL-F on Windows, or the Command-F on a Mac, to bring up the “Find and Replace” window.
4. Go to the Replace tab, enter “Cruise” in the “Find What” box and nothing in the “Replace with” box, hit “Replace all”
5. Repeat the previous step for the word “BLOS” and close the window
6. Delete the rows with “Pier” as a Station value (only occur in 2012)
7. Rename the column “Cruise ID” to “Cruise”
7. Save and close the CSV file.

# Importing the data sets

Now we have our two data sets saved as separate CSV files. Let's load each of them into R. But first... we need to start our R session by

1. Setting our working directory
2. Importing the packages we need for today

```{r}
setwd("C:/Users/cmitchell/Documents/SeaChangeSemester/2021/Labs/sea-change-semester-data-labs/Lab03/")

library(dplyr)
library(ggplot2)
```

Ok, so now we are ready to import our data sets. We are going to load each one into a separate data frame:

```{r}
ctdData <- read.csv('DaRTS_CTD_data.csv')
discreteData <- read.csv('DaRTS_discrete_data.csv')
```

# Combining data sets

Often you have two different data sets that you would like to combine. For example, matching the discrete data to the CTD data from the DaRTS data sets.

Typically, we will want to match the data based on key identifying each information: the cruise date, the station number and depth. For the DaRTS data, the different cruises are identified by the date. And, depending on your exact end goal / question, we'll need to think a bit carefully about how we want to match by depth (for example are you matching discrete to CTD data, or integrated data to discrete data, etc).

## Dates

We know one of our key identifying pieces of information is date. So let's take a closer look at the dates in each of our data sets.

First, let's pull out just the dates column:

```{r}
# one way
ctdDates <- ctdData$Date

# another way:
ctdDates <- ctdData[['Date']]

# and the discrete dates
discreteDates <- discreteData$Date
```

In the above two ways of pulling out the dates column we ended up with a vector object. 

You can also pull out the dates column and have it as a 1 column data frame:

```{r}
ctdDates_df <- ctdData['Date']
```


What format are these dates in? You can check by manually opening the two data frames (`ctdData` and `discreteData`) and looking at the Dates column (i.e. double click on the data frames in the Environment Panel). Or we can check using R:

```{r}
ctdDates[1]
```

What type of data is this? A number? 
```{r}
class(ctdDates[1])
```
Numbers that do not contain decimal values have a data type as an integer. 

What about the discrete data dates?
```{r}
discreteDates[1]
class(discreteDates[1])
```

A character can be a letter/number or a combination of letters and/or numbers enclosed by quotes. 

So in each case, the dates are different formats and different data types. Let's make them the same format and data type - this will make things much easier for matching the discrete and CTD data.

Should we have our dates represented by numeric values? Or characters?

If we use characters, we need to be careful about knowing which part of the date is the month, day and year: in the US it's normal for dates to be month/day/year, but in almost every other country it's day/month/year. This can lead to a lot of confusion when working collaboratively with international participants, or even within a research group if someone from Scotland joins a team of Americans! In addition to the confusion about the day-month-year order, when we use characters, it's really difficult to do any date math e.g. counting how many days between two dates.

This may make it seem like numbers are a better option - but this can still lead to difficulties when wanting to do date math, e.g. if you want to know how many days there are between dates that span multiple months, you need to know how many days are in each of those months, and if one of those months is February, are you in a leap year?

As you can see, we need to approach dates (& times) carefully. Most programming languages have their own class of data for dates & times (i.e. not numeric or characters). So a lot of those difficulties I mentioned are dealt with behind the scenes by the different date math functions that exist. 

R deals with dates and times in a couple of different ways. We're going to use the [`lubridate`](https://lubridate.tidyverse.org/) package which is part of the `tidyverse`. There's [this great cheat sheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf) which gives an overview of a lot of the functionality of the `lubridate` package.

### Date reformatting

Let's first load the `lubridate` package

```{r}
library("lubridate")
```

Now, let's deal with the CTD dates. We can use the `ymd` function to tell `lubridate` that our date is currently a number stored in the format yyyymmdd.

```{r}
ctdDates <- lubridate::ymd(ctdData$Date)
```

What do these look like? 

```{r}
ctdDates[1]
```

And what data type are they?

```{r}
class(ctdDates)
```

OK great - now what about the discrete dates? We can't use the same approach as above because our discrete dates are characters of the form mm/dd/yyyy. But we can use something really similar:

```{r}
discreteDates <- lubridate::mdy(discreteData$Date)
```

And let's just check what these dates look like and their type:

```{r}
discreteDates[1]
class(discreteDates)
```

Great - now we have nicely formatted dates that we can use later to match our CTD and discrete data together. To make this task easier, we want to include a new column in each of our data frames that contains these newly formatted dates. To do this, we are going to use `dplyr`'s `mutate` function. We used `filter` from `dplyr` last day. `dplyr` is another part of the `tidyverse` that is for data frame manipulation.

### Adding new columns to a data frame with `mutate`

In the following, we are going to add a new column to our data frames with these newly formatted dates. In each case, the new column will have the name `Date_r`.

```{r}
ctdData <- mutate(ctdData, Date_r = ymd(ctdData$Date))

discreteData <- mutate(discreteData, Date_r = mdy(discreteData$Date))
```

To do any type of data frame manipulations, you can use *pipes*. Pipes are a recent addition to R. They let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipe has the symbol `%>%`. We'll make full use of pipes later, but to add the dates column to the ctdData data frame using pipes you would do:

```{r}
ctdData <- ctdData %>% mutate(Date_r = ymd(ctdData$Date))
```

This is equivalent to `ctdData <- mutate(ctdData, Date_r = ymd(ctdData$Date))`. Note if a column already exists with the name you are assigning in the mutate function, the original column will be overwritten.


## Merging the discrete and CTD data

There are multiple ways to merge the datasets depending on the exact combination of variables you want e.g. do you want all the stations and/or all the depths and/or only one station and/or multiple years, etc.

To figure out the way to do the merge, we need to break down the process into the most basic/small steps. This is good practice for any kind of code development: breaking down your task into discrete, bitesize bundles. Think about building a robot to make a sandwich. You couldn't just code "make a sandwich", you'd need to break it down into steps, like a recipe e.g. go to the cupboard, take out the bread, put it on the table, etc. Some of those steps may seem obvious to you, but it wouldn't be to a robot. So when we're thinking about how to write our code, we often start with a great question e.g. 

Here, we are look







